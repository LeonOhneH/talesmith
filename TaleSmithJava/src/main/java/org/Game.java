package main.java.org;

import main.java.org.builder.RoomBuilder;
import main.java.org.service.CombatService;
import main.java.org.service.CombatService.*;
import main.java.org.service.DropService;
import main.java.org.templates.*;
import main.java.org.ui.GameRenderer;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Game {
    private String name;
    private List<RoomTemplate> roomTemplates;
    private List<EnemyTemplate> enemyTemplates;
    private Player player;
    private Room currentRoom;
    private Random random;
    private int roomsCleared;
    private int totalEnemiesKilled;
    private int difficultyLevel;
    private GameRenderer renderer;
    private CombatService combatService;
    private DropService dropService;

    public Game(String name, List<RoomTemplate> roomTemplates, Player player, GameRenderer renderer) {
        this.name = name;
        this.roomTemplates = roomTemplates;
        this.player = player;
        this.renderer = renderer;
        this.random = new Random();
        this.roomsCleared = 0;
        this.totalEnemiesKilled = 0;
        this.difficultyLevel = 1;
        this.combatService = new CombatService();
        this.dropService = new DropService();
    }

    // Die start() Methode aktualisieren, um das Neustart-Feature zu unterst√ºtzen
    public void start() {
        boolean playAgain = true;

        while (playAgain) {
            // Spiel zur√ºcksetzen, falls es nicht der erste Durchlauf ist
            resetGame();

            renderer.clearScreen();
            displayWelcome();

            int result = 0;
            while (result == 0 && !player.isDead()) {
                result = roomLoop();

                if (result == 0) { // Erfolgreich geschafft
                    roomsCleared++;
                    if (roomsCleared % 3 == 0) {
                        difficultyLevel++;
                    }
                    displayRoomCleared();
                }
            }

            // Spielende anzeigen und fragen, ob eine neue Runde gespielt werden soll
            playAgain = displayGameOver();
        }
    }

    // Diese Methode hinzuf√ºgen, um den Spielstatus zur√ºckzusetzen
    private void resetGame() {
        roomsCleared = 0;
        totalEnemiesKilled = 0;
        difficultyLevel = 1;

        // Spieler zur√ºcksetzen
        player.setHp(100);
        player.setMaxHp(100);
        player.setAp(50);
        player.setAgility(40);
        player.setLevel(1);
        player.setExperience(0);
        player.getInventory().clear();
    }

    private void displayWelcome() {
        String[] content = {
                "",
                "üåü Willkommen bei " + name + "! üåü",
                "",
                "Du bist " + player.getName() + ", ein tapferer Held!",
                "",
                "Deine Mission: √úberlebe so viele R√§ume wie m√∂glich!",
                "Mit jedem Raum steigt die Schwierigkeit.",
                "",
                "Viel Gl√ºck! ‚öîÔ∏è",
                "",
                "Dr√ºcke Enter um zu beginnen..."
        };

        renderer.drawBox("WILLKOMMEN", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    public int roomLoop() {
        generateNewRoom();
        displayRoomEntry();

        while (!currentRoom.isCleared()) {
            if (player.isDead()) {
                return 1;
            }

            displayRoomStatus();
            int choice = renderer.getValidInput(1, 5);

            switch (choice) {
                case 1:
                    handleFight();
                    break;
                case 2:
                    displayPlayerStats();
                    break;
                case 3:
                    displayInventory();
                    break;
                case 4:
                    displayGameStats();
                    break;
                case 5:
                    if (confirmQuit())
                        return 1;
                    break;
            }
        }

        return 0;
    }

    private void displayRoomEntry() {
        String[] content = {
                "",
                "üèõÔ∏è Du betrittst " + currentRoom.getName() + "!",
                "",
                "üëπ Feinde im Raum: " + currentRoom.getEnemies().size(),
                "",
                "üéØ Schwierigkeit: Level " + difficultyLevel,
                "",
                "Dr√ºcke Enter um fortzufahren..."
        };

        renderer.drawBox("NEUER RAUM", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    private void displayRoomStatus() {
        List<String> content = new ArrayList<>();
        content.add("");
        content.add("üìç " + currentRoom.getName() + " (Level " + difficultyLevel + ")");
        content.add("");

        // Spieler Status
        content.add("üë§ " + player.getName() + " (Lv." + player.getLevel() + ")");
        content.add(getHealthBarString(player));
        content.add("‚ö° Initiative: " + player.getAgility() + "   ‚öîÔ∏è AP: " + player.getAp());
        content.add("");

        // Gegner Status mit korrekter Ausrichtung
        List<Enemy> allEnemies = currentRoom.getEnemies();
        content.add("üëπ Gegner (" + allEnemies.size() + "):");
        // Korrigierter Tabellenkopf mit festen Spaltenbreiten
        content.add("   # | Name                 | HP       | AP  | Initiative    ");
        content.add("   --+----------------------+----------+-----+--------------");

        // Alle Gegner anzeigen mit korrekter Ausrichtung
        for (int i = 0; i < allEnemies.size(); i++) {
            Enemy enemy = allEnemies.get(i);
            // Verwende ein konsistentes Format mit festen Spaltenbreiten
            String status = String.format("   %2d | %-20s | %3d/%-4d | %3d | %-12d",
                    (i + 1),
                    formatName(enemy.getName(), 20),
                    enemy.getHp(),
                    enemy.getMaxHp(),
                    enemy.getAp(),
                    enemy.getAgility());

            if (!enemy.isAlive()) {
                status += " üíÄ";
            }

            content.add(status);
        }

        content.add("");
        content.add("‚öîÔ∏è Was m√∂chtest du tun?");
        content.add("1. üó°Ô∏è K√§mpfen  2. üìä Stats  3. üéí Inventar  4. üìà Info  5. üö™ Beenden");
        content.add("");
        content.add("Deine Wahl: ");

        renderer.drawBox("AKTUELLER RAUM", content.toArray(new String[0]));
    }

    // Hilfsmethode um Namen zu k√ºrzen oder aufzuf√ºllen
    private String formatName(String name, int length) {
        if (name.length() > length) {
            return name.substring(0, length - 3) + "...";
        }
        return name;
    }

    private void handleFight() {
        List<Enemy> aliveEnemies = currentRoom.getAliveEnemies();
        if (aliveEnemies.isEmpty()) {
            String[] content = {
                    "",
                    "üéâ Alle Gegner wurden bereits besiegt!",
                    "",
                    "Dr√ºcke Enter um fortzufahren..."
            };
            renderer.drawBox("KAMPF", content);
            renderer.getInput();
            renderer.clearScreen();
            return;
        }

        // Gegner ausw√§hlen mit tabellarischer Darstellung
        List<String> content = new ArrayList<>();
        content.add("");
        content.add("‚öîÔ∏è Welchen Gegner m√∂chtest du angreifen?");
        content.add("");

        // Korrigierter Tabellenkopf mit festen Spaltenbreiten
        content.add("   # | Name                 | HP       | AP  | Initiative    ");
        content.add("   --+----------------------+----------+-----+--------------");

        // Gegner-Liste mit ausgerichteten Spalten
        for (int i = 0; i < aliveEnemies.size(); i++) {
            Enemy enemy = aliveEnemies.get(i);
            String formattedRow = String.format("   %2d | %-20s | %3d/%-4d | %3d | %-12d",
                    (i + 1),
                    formatName(enemy.getName(), 20),
                    enemy.getHp(),
                    enemy.getMaxHp(),
                    enemy.getAp(),
                    enemy.getAgility());

            content.add(formattedRow);
        }

        content.add("");
        content.add("Deine Wahl: ");

        renderer.drawBox("GEGNER W√ÑHLEN", content.toArray(new String[0]));

        int choice = renderer.getValidInput(1, aliveEnemies.size());
        Enemy targetEnemy = aliveEnemies.get(choice - 1);

        renderer.clearScreen();

        // Kampf √ºber CombatService ausf√ºhren
        executeCombatWithAnimation(player, targetEnemy);

        if (targetEnemy.isDead()) {
            totalEnemiesKilled++;

            // Level-Up Behandlung
            int oldLevel = player.getLevel();
            int expGain = combatService.calculateExperienceGain(targetEnemy);
            player.gainExperience(expGain);

            if (player.getLevel() > oldLevel) {
                displayPlayerLevelUp(oldLevel, player.getLevel());
            }

            // Item-Drops
            handleEnemyDrops(targetEnemy);

            int healAmount = 5;
            player.heal(healAmount);

            currentRoom.checkCleared();
        }
    }

    private void handleEnemyDrops(Enemy enemy) {
        // 1. Drops aus dem Raum
        List<Item> roomDrops = currentRoom.getDrops();
        if (roomDrops != null && !roomDrops.isEmpty() && random.nextFloat() < 0.05f) { // 5% Chance
            Item droppedItem = roomDrops.get(random.nextInt(roomDrops.size()));
            player.addItem(droppedItem);
            displayItemFound(droppedItem);
            return; // Wenn ein Raum-Drop erfolgt, keinen Gegner-Drop mehr
        }

        // 2. Gegnerspezifische Drops (10% Chance)
        if (enemy.getTemplate() != null && enemy.getTemplate().getPossibleDrops() != null &&
                random.nextFloat() < 0.3f) {
            // Hier benutzen wir den dropService um Items zu generieren
            List<Item> enemyDrops = dropService.generateDrops(enemy.getTemplate().getPossibleDrops());

            if (!enemyDrops.isEmpty()) {
                // Nehme einen zuf√§lligen Drop aus der Liste
                Item droppedItem = enemyDrops.get(random.nextInt(enemyDrops.size()));
                player.addItem(droppedItem);
                displayItemFound(droppedItem);
                return;
            }
        }

        // 3. Fallback: Generisches Item, wenn kein Template-Drop verf√ºgbar (8% Chance)
        if (random.nextFloat() < 0.05f) {
            // Erzeuge einen zuf√§lligen Gegenstand f√ºr den Gegner
            Weapon droppedWeapon = new Weapon(
                    "Waffe von " + enemy.getName(),
                    "Erbeutet von " + enemy.getName(),
                    5 + random.nextInt(10), // Zuf√§lliger Schaden 5-15
                    WeaponTypeE.class.getEnumConstants()[0]
            );

            player.addItem(droppedWeapon);
            displayItemFound(droppedWeapon);
        }
    }

    private void displayItemFound(Item item) {
        String itemType = item instanceof Weapon ? "‚öîÔ∏è Waffe" : "üß™ Gegenstand";

        String[] content = {
                "",
                "üéÅ GEGENSTAND GEFUNDEN! üéÅ",
                "",
                itemType + ": " + item.getName(),
                "",
                "üìù " + item.getDescription(),
                "",
                "‚úÖ Zum Inventar hinzugef√ºgt!",
                "",
                "Dr√ºcke Enter um fortzufahren..."
        };

        renderer.drawBox("LOOT!", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    private void displayPlayerStats() {
        // Berechne Gesamtangriffskraft mit bester Waffe
        int weaponDamage = getBestWeaponDamage();
        int totalAP = player.getAp() + weaponDamage;

        int currentExp = player.getExperience();
        int expNeeded = player.getExpNeededForNextLevel();

        String[] content = {
                "",
                "üë§ " + player.getName(),
                "",
                getHealthBarString(player),
                "",
                "‚öîÔ∏è Angriffskraft: " + player.getAp() + (weaponDamage > 0 ? " + " + weaponDamage + " (Waffe)" : ""),
                "üí™ Gesamt-AP: " + totalAP,
                "‚ö° Geschwindigkeit: " + player.getAgility(),
                "üéØ Level: " + player.getLevel(),
                "‚ú® Erfahrung: " + currentExp + "/" + expNeeded,
                getExpBarString(currentExp, expNeeded),
                "üéí Inventar: " + player.getInventory().size() + " Gegenst√§nde",
                "",
                "Dr√ºcke Enter um zur√ºckzukehren..."
        };

        renderer.drawBox("CHARAKTERWERTE", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    private String getExpBarString(int currentExp, int expNeeded) {
        double expPercent = (double) currentExp / expNeeded;

        int barWidth = 15;
        int filledBars = (int) (expPercent * barWidth);
        StringBuilder expBar = new StringBuilder();

        expBar.append("‚ú® ");

        for (int i = 0; i < filledBars; i++) {
            expBar.append("‚ñà");
        }

        for (int i = filledBars; i < barWidth; i++) {
            expBar.append("‚ñë");
        }

        expBar.append(" ").append((int) (expPercent * 100)).append("%");

        return expBar.toString();
    }

    private int getBestWeaponDamage() {
        int maxDamage = 0;
        for (Item item : player.getInventory()) {
            if (item instanceof Weapon) {
                Weapon weapon = (Weapon) item;
                if (weapon.getDamage() > maxDamage) {
                    maxDamage = weapon.getDamage();
                }
            }
        }
        return maxDamage;
    }

    private void displayInventory() {
        List<String> content = new ArrayList<>();
        content.add("");
        content.add("üéí INVENTAR");
        content.add("");

        if (player.getInventory().isEmpty()) {
            content.add("üì≠ Inventar ist leer!");
        } else {
            for (int i = 0; i < player.getInventory().size(); i++) {
                Item item = player.getInventory().get(i);
                String itemIcon = item instanceof Weapon ? "‚öîÔ∏è" : "üß™";
                content.add((i + 1) + ". " + itemIcon + " " + item.getName());

                if (item instanceof Weapon) {
                    Weapon weapon = (Weapon) item;
                    content.add("   ‚îî Schaden: +" + weapon.getDamage());
                }
            }
        }

        content.add("");
        content.add("Dr√ºcke Enter um zur√ºckzukehren...");

        renderer.drawBox("INVENTAR", content.toArray(new String[0]));
        renderer.getInput();
        renderer.clearScreen();
    }

    private void displayPlayerLevelUp(int oldLevel, int newLevel) {
        renderer.clearScreen();
        String[] content = {
                "",
                "üéä LEVEL UP! üéä",
                "",
                "Level " + oldLevel + " ‚Üí Level " + newLevel,
                "",
                "üìà Statusverbesserungen:",
                "‚ù§Ô∏è HP +20 (vollst√§ndig geheilt)",
                "‚öîÔ∏è AP +2",
                "‚ö° Agility +1",
                "",
                "Dr√ºcke Enter um fortzufahren..."
        };
        renderer.drawBox("LEVEL UP!", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    private void displayGameStats() {
        String[] content = {
                "",
                "üèõÔ∏è R√§ume abgeschlossen: " + roomsCleared,
                "üíÄ Gegner besiegt: " + totalEnemiesKilled,
                "üî• Schwierigkeitsgrad: Level " + difficultyLevel,
                "üèÜ Spieler Level: " + player.getLevel(),
                "",
                "Dr√ºcke Enter um zur√ºckzukehren..."
        };

        renderer.drawBox("SPIELSTATISTIKEN", content);
        renderer.getInput();
        renderer.clearScreen();
    }

    private String getHealthBarString(Creature creature) {
        int maxHp = creature.getMaxHp();
        int currentHp = creature.getHp();
        double healthPercent = (double) currentHp / maxHp;

        String healthIcon;
        if (healthPercent > 0.75) {
            healthIcon = "‚ù§Ô∏è";
        } else if (healthPercent > 0.5) {
            healthIcon = "üß°";
        } else if (healthPercent > 0.25) {
            healthIcon = "üíõ";
        } else if (healthPercent > 0) {
            healthIcon = "üíî";
        } else {
            healthIcon = "üíÄ";
        }

        int barWidth = 15;
        int filledBars = (int) (healthPercent * barWidth);
        StringBuilder healthBar = new StringBuilder();

        healthBar.append(healthIcon).append(" ");

        for (int i = 0; i < filledBars; i++) {
            healthBar.append("‚ñà");
        }

        for (int i = filledBars; i < barWidth; i++) {
            healthBar.append("‚ñë");
        }

        healthBar.append(" ").append(currentHp).append("/").append(maxHp);

        return healthBar.toString();
    }

    private boolean confirmQuit() {
        String[] content = {
                "",
                "‚ùì M√∂chtest du wirklich das Spiel beenden?",
                "",
                "(j/n): "
        };

        renderer.drawBox("SPIEL BEENDEN?", content);

        String input = renderer.getInput().toLowerCase();
        return input.equals("j") || input.equals("ja");
    }

    private void displayRoomCleared() {
        String[] content = {
                "",
                "‚ú® RAUM ERFOLGREICH ABGESCHLOSSEN! ‚ú®",
                "",
                "üèõÔ∏è Raum #" + (roomsCleared + 1) + " gemeistert!",
                "",
                "üíö Du erholst dich...",
                "",
                "Bereit f√ºr den n√§chsten Raum?"
        };

        renderer.drawBox("SIEG!", content);

        int healAmount = Math.max(10, 25 - difficultyLevel);
        player.heal(healAmount);

        renderer.sleep(2000);
        renderer.clearScreen();
    }

    // Die displayGameOver Methode anpassen, um eine R√ºckgabe f√ºr "Neue Runde" zu
    // haben
    private boolean displayGameOver() {
        String rating = "";
        if (roomsCleared >= 50)
            rating = "üåü LEGEND√ÑR! üåü";
        else if (roomsCleared >= 30)
            rating = "üíé MEISTERHAFT! üíé";
        else if (roomsCleared >= 20)
            rating = "üèÜ HERVORRAGEND! üèÜ";
        else if (roomsCleared >= 10)
            rating = "‚≠ê GUT! ‚≠ê";
        else if (roomsCleared >= 5)
            rating = "üëç ORDENTLICH! üëç";
        else
            rating = "üéØ √úbung macht den Meister!";

        String[] content = {
                "",
                "üíÄ GAME OVER üíÄ",
                "",
                "üìä ENDSTATISTIKEN:",
                "üèõÔ∏è R√§ume √ºberlebt: " + roomsCleared,
                "üíÄ Gegner besiegt: " + totalEnemiesKilled,
                "üî• Schwierigkeit: Level " + difficultyLevel,
                "üèÜ Spieler-Level: " + player.getLevel(),
                "",
                "üéñÔ∏è " + rating,
                "",
                "M√∂chtest du noch eine Runde spielen? (j/n): "
        };

        renderer.drawBox("SPIEL BEENDET", content);

        // Eingabe abfragen und auswerten
        String input = renderer.getInput().toLowerCase();
        return input.equals("j") || input.equals("ja");
    }

    private void executeCombatWithAnimation(Player player, Enemy enemy) {
        // Nur EINE Box f√ºr den gesamten Kampf erstellen
        renderer.clearScreen();
        String[] initialContent = {
                "",
                "‚öîÔ∏è KAMPF BEGINNT! ‚öîÔ∏è",
                "",
                player.getName() + " VS " + enemy.getName(),
                "",
                "Kampf wird vorbereitet...",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
        };

        renderer.drawBox("KAMPF", initialContent);
        renderer.sleep(800);

        // Schritt 1: Kampfstatistiken in derselben Box zeigen
        boolean playerFirst = combatService.determineAttackOrder(player, enemy);
        String[] statsContent = {
                "",
                "‚öîÔ∏è KAMPFSTATISTIK ‚öîÔ∏è",
                "",
                "üë§ " + player.getName() + ":",
                "   ‚ù§Ô∏è HP: " + player.getHp() + "/" + player.getMaxHp(),
                "   ‚öîÔ∏è AP: " + player.getAp(),
                "   ‚ö° Speed: " + player.getAgility(),
                "",
                "üëπ " + enemy.getName() + ":",
                "   ‚ù§Ô∏è HP: " + enemy.getHp() + "/" + enemy.getMaxHp(),
                "   ‚öîÔ∏è AP: " + enemy.getAp(),
                "   ‚ö° Speed: " + enemy.getAgility(),
                "",
                playerFirst ? "‚ö° " + player.getName() + " ist schneller und greift zuerst an!"
                        : "‚ö° " + enemy.getName() + " ist schneller und greift zuerst an!"
        };
        renderer.updateBoxContent(statsContent, 1);
        renderer.sleep(1500);

        // Kampf ausf√ºhren
        CombatResult result = combatService.executeCombat(player, enemy);

        // Schritt 2: Kampfverlauf in derselben Box animieren - OHNE Fortschrittsbalken
        List<CombatService.AttackResult> attackHistory = result.getAttackHistory();
        int maxAttacks = Math.min(attackHistory.size(), 10); // Erh√∂he auf 10 f√ºr mehr sichtbare Angriffe
        List<String> combatLog = new ArrayList<>();

        // Titel f√ºr Kampfverlauf
        String[] progressHeader = {
                "",
                "‚öîÔ∏è KAMPFVERLAUF ‚öîÔ∏è",
                "",
                "Der Kampf beginnt...",
                ""
        };
        renderer.updateBoxContent(progressHeader, 1);
        renderer.sleep(500);

        // Jetzt den Kampf Zug f√ºr Zug animieren
        for (int i = 0; i < maxAttacks; i++) {
            CombatService.AttackResult attack = attackHistory.get(i);
            combatLog.add(formatAttackMessage(attack));

            // Erstelle Array mit Header und bisherigen Kampfmeldungen
            String[] updatedContent = new String[3 + combatLog.size()];
            updatedContent[0] = "";
            updatedContent[1] = "‚öîÔ∏è KAMPFVERLAUF ‚öîÔ∏è";
            updatedContent[2] = "";

            for (int j = 0; j < combatLog.size(); j++) {
                updatedContent[3 + j] = combatLog.get(j);
            }

            renderer.updateBoxContent(updatedContent, 1);
            renderer.sleep(600);
        }

        // Evtl. Zusammenfassung f√ºr weitere Angriffe
        if (attackHistory.size() > maxAttacks) {
            combatLog.add("..." + (attackHistory.size() - maxAttacks) + " weitere Angriffe...");
        }

        // Abschluss des Kampfverlaufs mit allen sichtbaren Angriffen
        String[] finalProgressContent = new String[3 + combatLog.size()];
        finalProgressContent[0] = "";
        finalProgressContent[1] = "‚öîÔ∏è KAMPFVERLAUF ‚öîÔ∏è";
        finalProgressContent[2] = "";

        for (int j = 0; j < combatLog.size(); j++) {
            finalProgressContent[3 + j] = combatLog.get(j);
        }

        renderer.updateBoxContent(finalProgressContent, 1);
        renderer.sleep(1000);

        // Schritt 3: Kampfergebnis in derselben Box zeigen
        String outcomeMessage;
        String detailMessage;
        String expMessage = "";
        String healMessage = "";

        switch (result.getOutcome()) {
            case PLAYER_DEFEATED:
                outcomeMessage = "üíÄ " + player.getName() + " wurde besiegt!";
                detailMessage = "Das Abenteuer endet hier...";
                break;
            case ENEMY_DEFEATED:
                outcomeMessage = "üéâ " + player.getName() + " hat gewonnen!";
                detailMessage = "üèÜ Sieg nach " + result.getRounds() + " Runden!";
                expMessage = "‚ú® Du erh√§ltst Erfahrungspunkte!";
                healMessage = "üíö Du erholst dich etwas!";
                break;
            case TIME_LIMIT:
                outcomeMessage = "‚è∞ Kampf nach " + result.getRounds() + " Runden beendet!";
                detailMessage = "(Zeitlimit erreicht)";
                break;
            default:
                outcomeMessage = "Kampf beendet.";
                detailMessage = "";
        }

        String[] resultContent = {
                "",
                "üî• KAMPF BEENDET! üî•",
                "",
                outcomeMessage,
                detailMessage,
                expMessage,
                healMessage,
                "",
                "",
                "",
                "",
                "",
                "Dr√ºcke Enter um fortzufahren..."
        };

        renderer.updateBoxContent(resultContent, 1);
        renderer.getInput();
        renderer.clearScreen();
    }

    // Du kannst die alten Methoden l√∂schen oder als private markieren,
    // da wir sie nicht mehr verwenden:
    // private void showCombatStatsInPlace(Player player, Enemy enemy) { ... }
    // private void showCombatRoundsInPlace(List<CombatService.AttackResult>
    // attackHistory) { ... }
    // private void showCombatResultInPlace(CombatResult result, Player player,
    // Enemy enemy) { ... }

    // Diese Methode behalten wir bei
    private String formatAttackMessage(CombatService.AttackResult attack) {
        StringBuilder message = new StringBuilder();

        // Kritischer Treffer?
        String criticalText = attack.isCriticalHit() ? "‚ö° KRITISCH! ‚ö° " : "";

        message.append(criticalText)
                .append(attack.getAttackerName())
                .append(" ‚Üí ")
                .append(attack.getTargetName())
                .append(": ")
                .append(attack.getDamage())
                .append(" Schaden (")
                .append(attack.getOldHp())
                .append(" ‚Üí ")
                .append(attack.getNewHp())
                .append(" HP)");

        if (attack.isTargetDied()) {
            message.append(" üíÄ");
        }

        return message.toString();
    }

    public void generateNewRoom() {
        RoomTemplate template = roomTemplates.get(random.nextInt(roomTemplates.size()));
        this.setCurrentRoom(new RoomBuilder()
                .withTemplate(template)
                .withDifficultyLevel(difficultyLevel)
                .generateEnemies()
                .build());
    }

    // Getter und Setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<RoomTemplate> getRoomTemplates() {
        return roomTemplates;
    }

    public void setRoomTemplates(List<RoomTemplate> roomTemplates) {
        this.roomTemplates = roomTemplates;
    }

    public List<EnemyTemplate> getEnemyTemplates() {
        return enemyTemplates;
    }

    public void setEnemyTemplates(List<EnemyTemplate> enemyTemplates) {
        this.enemyTemplates = enemyTemplates;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public Room getCurrentRoom() {
        return currentRoom;
    }

    public void setCurrentRoom(Room currentRoom) {
        this.currentRoom = currentRoom;
    }

    public int getDifficultyLevel() {
        return difficultyLevel;
    }

    public void setDifficultyLevel(int difficultyLevel) {
        this.difficultyLevel = difficultyLevel;
    }
}